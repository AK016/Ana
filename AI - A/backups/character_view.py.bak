#!/usr/bin/env python3
# Ana AI Assistant - Character Visualization Module

import os
import time
import random
import logging
import math
from threading import Thread, Event
from typing import Dict, List, Any, Optional
import glob

from PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel
from PyQt5.QtCore import Qt, QSize, pyqtSignal, QTimer, QPropertyAnimation, QPoint, QEasingCurve, QRect
from PyQt5.QtGui import QPixmap, QPainter, QColor, QPen, QBrush, QRadialGradient, QPainterPath, QImage
from PyQt5.QtSvg import QSvgRenderer

logger = logging.getLogger('Ana.CharacterView')

class CharacterView(QWidget):
    """
    Character visualization for Ana using anime-style assets with animations
    
    Features:
    - Pre-made anime-style character assets
    - Facial expressions and emotions
    - Speech and listening animations
    - Idle animations and gestures
    """
    
    # Signals
    animation_complete = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMinimumSize(400, 400)
        
        # Character state
        self.current_emotion = "neutral"  # neutral, happy, sad, surprised, thinking
        self.is_speaking = False
        self.is_listening = False
        self.energy_level = 0.8  # 0.0 to 1.0
        
        # Animation parameters
        self.pulse_opacity = 0.0
        self.pulse_direction = 0.05
        self.eye_blink = False
        self.mouth_openness = 0.0
        self.head_offset = QPoint(0, 0)
        self.breath_offset = 0
        self.breath_in = True
        self.head_tilt = 0  # Add head tilt parameter
        
        # Cyberpunk color scheme - adjusted for dark-haired character
        self.primary_color = QColor(0, 220, 200)  # Cyan
        self.secondary_color = QColor(130, 0, 200)  # Purple
        self.accent_color = QColor(220, 50, 100)  # Pink
        self.bg_color = QColor(10, 15, 25)  # Dark blue-black
        
        # Character assets
        self.assets_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'assets', 'character')
        self.character_parts = {
            'base': None,  # Base face
            'eyes': {},    # Different eye states
            'mouth': {},   # Different mouth states
            'eyebrows': {},# Different eyebrow states
            'hair': None,  # Hair layer
            'blush': None, # Blush overlay
            'effects': {}  # Special effects like glows
        }
        
        # Debug mode - draw directly rather than using assets if True
        self.debug_mode = False
        
        # Current display layers
        self.current_eyes = 'neutral'
        self.current_mouth = 'neutral'
        self.current_eyebrows = 'neutral'
        self.current_effects = []
        
        # Set up layout
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        
        # Set up animation timers
        self.animation_timer = QTimer(self)
        self.animation_timer.timeout.connect(self.update_animation)
        self.animation_timer.start(33)  # ~30 fps
        
        self.blink_timer = QTimer(self)
        self.blink_timer.timeout.connect(self.blink_eyes)
        self.blink_timer.start(random.randint(3000, 6000))  # Random blink interval
        
        # Breathing animation
        self.breath_timer = QTimer(self)
        self.breath_timer.timeout.connect(self.update_breathing)
        self.breath_timer.start(50)  # Smooth breathing
        
        # Idle animation thread
        self.idle_stop_event = Event()
        self.idle_thread = Thread(target=self._idle_animation_loop, daemon=True)
        self.idle_thread.start()
        
        # Load character assets
        self.load_character_assets()
        
        logger.info("Character view initialized")
    
    def load_character_assets(self):
        """Load character assets from the assets folder"""
        logger.info("Loading character assets from: %s", self.assets_path)
        
        # Check if the assets directory exists, if not create placeholder assets
        if not os.path.exists(self.assets_path):
            os.makedirs(self.assets_path, exist_ok=True)
            self.create_placeholder_assets()
            logger.warning("Created placeholder assets as no assets were found")
        
        # Try to load existing assets
        try:
            # Base face
            base_path = os.path.join(self.assets_path, 'base.png')
            if os.path.exists(base_path):
                self.character_parts['base'] = QPixmap(base_path)
            
            # Hair
            hair_path = os.path.join(self.assets_path, 'hair.png')
            if os.path.exists(hair_path):
                self.character_parts['hair'] = QPixmap(hair_path)
            
            # Blush
            blush_path = os.path.join(self.assets_path, 'blush.png')
            if os.path.exists(blush_path):
                self.character_parts['blush'] = QPixmap(blush_path)
            
            # Eyes
            for eye_state in ['neutral', 'happy', 'sad', 'surprised', 'thinking', 'blink']:
                eye_path = os.path.join(self.assets_path, f'eyes_{eye_state}.png')
                if os.path.exists(eye_path):
                    self.character_parts['eyes'][eye_state] = QPixmap(eye_path)
            
            # Mouth
            for mouth_state in ['neutral', 'happy', 'sad', 'surprised', 'thinking', 'speak1', 'speak2', 'speak3']:
                mouth_path = os.path.join(self.assets_path, f'mouth_{mouth_state}.png')
                if os.path.exists(mouth_path):
                    self.character_parts['mouth'][mouth_state] = QPixmap(mouth_path)
            
            # Eyebrows
            for brow_state in ['neutral', 'happy', 'sad', 'surprised', 'thinking']:
                brow_path = os.path.join(self.assets_path, f'eyebrows_{brow_state}.png')
                if os.path.exists(brow_path):
                    self.character_parts['eyebrows'][brow_state] = QPixmap(brow_path)
            
            # Effects
            for effect_type in ['glow_teal', 'glow_purple', 'listening', 'speaking', 'thinking']:
                effect_path = os.path.join(self.assets_path, f'effect_{effect_type}.png')
                if os.path.exists(effect_path):
                    self.character_parts['effects'][effect_type] = QPixmap(effect_path)
            
            logger.info("Character assets loaded successfully")
        
        except Exception as e:
            logger.error(f"Error loading character assets: {str(e)}")
            self.create_placeholder_assets()
    
    def create_placeholder_assets(self):
        """Create placeholder assets for development"""
        logger.info("Creating placeholder character assets")
        
        # Create assets directory if it doesn't exist
        if not os.path.exists(self.assets_path):
            os.makedirs(self.assets_path, exist_ok=True)
            
        # Base face - create an anime-style oval face with skin tone
        base = QPixmap(400, 400)
        base.fill(Qt.transparent)
        painter = QPainter(base)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Face shape - more anime-like oval
        painter.setPen(QPen(QColor(60, 50, 55), 2))
        painter.setBrush(QBrush(QColor(255, 240, 235)))  # Lighter anime skin tone
        
        # Draw anime face shape (more oval than round)
        face_path = QPainterPath()
        face_path.moveTo(130, 100)
        face_path.quadTo(200, 80, 270, 100)  # Top curve
        face_path.quadTo(320, 200, 270, 300)  # Right side
        face_path.quadTo(200, 330, 130, 300)  # Chin
        face_path.quadTo(80, 200, 130, 100)   # Left side
        
        painter.drawPath(face_path)
        painter.end()
        self.character_parts['base'] = base
        base.save(os.path.join(self.assets_path, 'base.png'), 'PNG')
        
        # Hair - anime-style with colored highlights
        hair = QPixmap(400, 400)
        hair.fill(Qt.transparent)
        painter = QPainter(hair)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Hair is a significant feature in anime - make it more detailed
        # Dark hair with cyberpunk colored highlights
        hair_color = QColor(20, 25, 30)  # Very dark hair
        painter.setPen(Qt.NoPen)
        
        # Create hair shape - longer anime-style hair
        hair_path = QPainterPath()
        
        # Top/crown of hair
        hair_path.moveTo(100, 120)
        hair_path.quadTo(200, 60, 300, 120)
        
        # Right side of hair
        hair_path.lineTo(320, 180)
        hair_path.quadTo(330, 250, 320, 320)
        
        # Hair ends/tips at bottom
        hair_path.quadTo(280, 380, 200, 400)
        hair_path.quadTo(120, 380, 80, 320)
        
        # Left side of hair
        hair_path.quadTo(70, 250, 80, 180)
        hair_path.lineTo(100, 120)
        
        # Create gradient for the hair
        gradient = QLinearGradient(200, 100, 200, 400)
        gradient.setColorAt(0.0, hair_color)
        gradient.setColorAt(0.7, QColor(30, 35, 40))
        gradient.setColorAt(1.0, QColor(40, 45, 50))
        
        painter.setBrush(QBrush(gradient))
        painter.drawPath(hair_path)
        
        # Bangs across forehead - classic anime style
        bangs_path = QPainterPath()
        bangs_path.moveTo(120, 120)
        bangs_path.quadTo(150, 150, 170, 120)
        bangs_path.quadTo(200, 140, 230, 120)
        bangs_path.quadTo(250, 150, 280, 120)
        
        painter.drawPath(bangs_path)
        
        # Add colored cyberpunk highlights
        painter.setPen(QPen(QColor(0, 220, 200, 120), 5))  # Cyan highlight
        painter.drawLine(130, 150, 140, 350)
        painter.setPen(QPen(QColor(220, 50, 140, 120), 5))  # Pink highlight
        painter.drawLine(270, 150, 260, 350)
        
        painter.end()
        self.character_parts['hair'] = hair
        hair.save(os.path.join(self.assets_path, 'hair.png'), 'PNG')
        
        # Eyes for different states - more anime-like with larger eyes
        eye_states = {
            'neutral': {'size': 1.0, 'position': 0},
            'happy': {'size': 0.8, 'position': 0, 'shape': 'curved'},
            'sad': {'size': 0.9, 'position': 5, 'shape': 'droopy'},
            'surprised': {'size': 1.2, 'position': -5, 'shape': 'wide'},
            'thinking': {'size': 1.0, 'position': -3, 'shape': 'looking_up'},
            'blink': {'size': 0.1, 'position': 0, 'shape': 'closed'}
        }
        
        for state, params in eye_states.items():
            eyes = QPixmap(400, 400)
            eyes.fill(Qt.transparent)
            painter = QPainter(eyes)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Eye parameters - larger anime eyes
            eye_width = 45 * params['size']
            eye_height = 30 * params['size']
            left_eye_x = 150
            right_eye_x = 250
            eye_y = 180 + params['position']
            
            # Draw eye whites
            painter.setPen(QPen(QColor(40, 40, 50), 2))
            painter.setBrush(QBrush(QColor(245, 245, 250)))
            
            if state == 'happy' and params.get('shape') == 'curved':
                # Happy anime eyes - curved upward
                painter.drawEllipse(left_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 0.7)
                painter.drawEllipse(right_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 0.7)
            elif state == 'sad' and params.get('shape') == 'droopy':
                # Sad anime eyes - droopy
                painter.drawEllipse(left_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 0.8)
                painter.drawEllipse(right_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 0.8)
            elif state == 'surprised' and params.get('shape') == 'wide':
                # Surprised anime eyes - very round
                painter.drawEllipse(left_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 1.2)
                painter.drawEllipse(right_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height * 1.2)
            elif state != 'blink':
                # Standard eye shape
                painter.drawEllipse(left_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height)
                painter.drawEllipse(right_eye_x - eye_width/2, eye_y - eye_height/2, eye_width, eye_height)
            
            # Draw irises and pupils if eyes are open
            if state != 'blink':
                # Vibrant anime iris color - cyberpunk blue
                iris_color = QColor(20, 180, 220)
                iris_size = eye_height * 0.7
                
                painter.setBrush(QBrush(iris_color))
                # Left iris
                painter.drawEllipse(left_eye_x - iris_size/2, eye_y - iris_size/2, iris_size, iris_size)
                # Right iris
                painter.drawEllipse(right_eye_x - iris_size/2, eye_y - iris_size/2, iris_size, iris_size)
                
                # Dark pupils
                painter.setBrush(QBrush(QColor(0, 0, 0)))
                pupil_size = iris_size * 0.5
                
                # Left pupil
                painter.drawEllipse(left_eye_x - pupil_size/2, eye_y - pupil_size/2, pupil_size, pupil_size)
                # Right pupil
                painter.drawEllipse(right_eye_x - pupil_size/2, eye_y - pupil_size/2, pupil_size, pupil_size)
                
                # Eye highlights - classic anime style
                painter.setPen(Qt.NoPen)
                painter.setBrush(QBrush(QColor(255, 255, 255, 220)))
                highlight_size = pupil_size * 0.6
                
                # Main highlights
                painter.drawEllipse(left_eye_x - pupil_size/3, eye_y - pupil_size/3, highlight_size, highlight_size)
                painter.drawEllipse(right_eye_x - pupil_size/3, eye_y - pupil_size/3, highlight_size, highlight_size)
                
                # Secondary smaller highlights
                highlight_size = pupil_size * 0.3
                painter.drawEllipse(left_eye_x + pupil_size/3, eye_y + pupil_size/3, highlight_size, highlight_size)
                painter.drawEllipse(right_eye_x + pupil_size/3, eye_y + pupil_size/3, highlight_size, highlight_size)
            else:
                # Closed eyes - simple curved lines
                painter.setPen(QPen(QColor(40, 40, 50), 2))
                
                # Left eye closed
                closed_eye_path = QPainterPath()
                closed_eye_path.moveTo(left_eye_x - eye_width/2, eye_y)
                closed_eye_path.quadTo(left_eye_x, eye_y + 5, left_eye_x + eye_width/2, eye_y)
                painter.drawPath(closed_eye_path)
                
                # Right eye closed
                closed_eye_path = QPainterPath()
                closed_eye_path.moveTo(right_eye_x - eye_width/2, eye_y)
                closed_eye_path.quadTo(right_eye_x, eye_y + 5, right_eye_x + eye_width/2, eye_y)
                painter.drawPath(closed_eye_path)
            
            painter.end()
            self.character_parts['eyes'][state] = eyes
            eyes.save(os.path.join(self.assets_path, f'eyes_{state}.png'), 'PNG')
        
        # Mouth for different states - more anime-style expressions
        mouth_states = {
            'neutral': {'width': 30, 'height': 3, 'curve': 0},
            'happy': {'width': 40, 'height': 10, 'curve': 10},
            'sad': {'width': 30, 'height': 10, 'curve': -10},
            'surprised': {'width': 25, 'height': 25, 'curve': 0},
            'thinking': {'width': 20, 'height': 5, 'curve': -5},
            'speak1': {'width': 35, 'height': 15, 'curve': 5},
            'speak2': {'width': 30, 'height': 20, 'curve': 0},
            'speak3': {'width': 25, 'height': 10, 'curve': -5}
        }
        
        for state, params in mouth_states.items():
            mouth = QPixmap(400, 400)
            mouth.fill(Qt.transparent)
            painter = QPainter(mouth)
            painter.setRenderHint(QPainter.Antialiasing)
            
            mouth_x = 200
            mouth_y = 260
            width = params['width']
            height = params['height']
            curve = params['curve']
            
            # Mouth color
            painter.setPen(QPen(QColor(220, 120, 140), 2))
            
            if state == 'surprised' or state.startswith('speak'):
                # Open mouth for surprised or speaking
                painter.setBrush(QBrush(QColor(150, 60, 80, 150)))
                painter.drawEllipse(mouth_x - width/2, mouth_y - height/2, width, height)
                
                # Add highlight/gloss for open mouth
                if state.startswith('speak'):
                    painter.setPen(QPen(QColor(255, 180, 200, 120), 1))
                    painter.drawLine(mouth_x - width/4, mouth_y - height/4, mouth_x + width/4, mouth_y - height/4)
            else:
                # Closed mouth with expression
                path = QPainterPath()
                path.moveTo(mouth_x - width/2, mouth_y)
                path.quadTo(mouth_x, mouth_y + curve, mouth_x + width/2, mouth_y)
                
                painter.drawPath(path)
                
                # For happy mouth, add a second curve to make it more anime-like
                if state == 'happy':
                    path = QPainterPath()
                    path.moveTo(mouth_x - width/3, mouth_y + 5)
                    path.quadTo(mouth_x, mouth_y + 15, mouth_x + width/3, mouth_y + 5)
                    painter.drawPath(path)
            
            painter.end()
            self.character_parts['mouth'][state] = mouth
            mouth.save(os.path.join(self.assets_path, f'mouth_{state}.png'), 'PNG')
        
        # Eyebrows for different states - more expressive
        brow_states = {
            'neutral': {'angle_left': -10, 'angle_right': 10, 'offset': 0},
            'happy': {'angle_left': -5, 'angle_right': 5, 'offset': -2},
            'sad': {'angle_left': 15, 'angle_right': -15, 'offset': 0},
            'surprised': {'angle_left': -20, 'angle_right': 20, 'offset': -10},
            'thinking': {'angle_left': 0, 'angle_right': -20, 'offset': -5}
        }
        
        for state, params in brow_states.items():
            brows = QPixmap(400, 400)
            brows.fill(Qt.transparent)
            painter = QPainter(brows)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Thicker eyebrows for more expression
            painter.setPen(QPen(QColor(20, 25, 30), 4, Qt.SolidLine, Qt.RoundCap))
            
            left_x, right_x = 150, 250
            y_pos = 150 + params['offset']
            width = 30
            
            # Left eyebrow
            painter.save()
            painter.translate(left_x, y_pos)
            painter.rotate(params['angle_left'])
            painter.drawLine(-width/2, 0, width/2, 0)
            painter.restore()
            
            # Right eyebrow
            painter.save()
            painter.translate(right_x, y_pos)
            painter.rotate(params['angle_right'])
            painter.drawLine(-width/2, 0, width/2, 0)
            painter.restore()
            
            painter.end()
            self.character_parts['eyebrows'][state] = brows
            brows.save(os.path.join(self.assets_path, f'eyebrows_{state}.png'), 'PNG')
        
        # Blush for happy/surprised expressions
        blush = QPixmap(400, 400)
        blush.fill(Qt.transparent)
        painter = QPainter(blush)
        painter.setRenderHint(QPainter.Antialiasing)
        
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(QColor(255, 150, 150, 100)))
        painter.drawEllipse(110, 220, 60, 30)
        painter.drawEllipse(230, 220, 60, 30)
        
        painter.end()
        self.character_parts['blush'] = blush
        blush.save(os.path.join(self.assets_path, 'blush.png'), 'PNG')
        
        # Effects - cyberpunk style glows
        effect_types = {
            'glow_teal': QColor(0, 220, 200, 40),
            'glow_purple': QColor(130, 0, 200, 40),
            'listening': QColor(220, 50, 100, 30),
            'speaking': QColor(0, 220, 200, 30),
            'thinking': QColor(130, 0, 200, 30)
        }
        
        for effect_type, color in effect_types.items():
            effect = QPixmap(400, 400)
            effect.fill(Qt.transparent)
            painter = QPainter(effect)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Create gradient
            gradient = QRadialGradient(200, 200, 150)
            gradient.setColorAt(0, color)
            gradient.setColorAt(1, QColor(color.red(), color.green(), color.blue(), 0))
            
            painter.setPen(Qt.NoPen)
            painter.setBrush(QBrush(gradient))
            painter.drawEllipse(50, 50, 300, 300)
            
            painter.end()
            self.character_parts['effects'][effect_type] = effect
            effect.save(os.path.join(self.assets_path, f'effect_{effect_type}.png'), 'PNG')
        
        logger.info("Placeholder anime character assets created")
    
    def paintEvent(self, event):
        """Paint the character visualization"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Get widget dimensions
        width = self.width()
        height = self.height()
        center_x = width / 2
        center_y = height / 2
        
        # Simple mode - just show a pulsing icon
        # Paint background
        painter.fillRect(self.rect(), self.bg_color)
        
        # Draw a pulsing circle with the primary color
        pulse_size = 70 + int(20 * self.pulse_opacity)
        glow_opacity = 0.5 + 0.5 * self.pulse_opacity
        
        # Draw outer glow
        painter.setPen(Qt.NoPen)
        glow_gradient = QRadialGradient(center_x, center_y, pulse_size * 1.5)
        glow_color = QColor(self.primary_color)
        glow_color.setAlphaF(0.1 * glow_opacity)
        glow_gradient.setColorAt(0, glow_color)
        glow_color.setAlphaF(0)
        glow_gradient.setColorAt(1, glow_color)
        painter.setBrush(QBrush(glow_gradient))
        painter.drawEllipse(
            int(center_x - pulse_size * 1.5),
            int(center_y - pulse_size * 1.5),
            int(pulse_size * 3),
            int(pulse_size * 3)
        )
        
        # Draw inner circle
        inner_color = QColor(self.primary_color)
        inner_color.setAlphaF(0.3 * glow_opacity)
        painter.setBrush(QBrush(inner_color))
        painter.drawEllipse(
            int(center_x - pulse_size / 2),
            int(center_y - pulse_size / 2),
            pulse_size,
            pulse_size
        )
        
        # Draw cyberpunk-style icon lines
        line_color = QColor(self.primary_color)
        line_color.setAlphaF(0.8 * glow_opacity)
        painter.setPen(QPen(line_color, 2))
        
        # Horizontal lines
        line_length = pulse_size * 0.6
        for i in range(3):
            y_offset = (i - 1) * pulse_size * 0.4
            # Left line
            painter.drawLine(
                int(center_x - pulse_size - line_length),
                int(center_y + y_offset),
                int(center_x - pulse_size),
                int(center_y + y_offset)
            )
            # Right line
            painter.drawLine(
                int(center_x + pulse_size),
                int(center_y + y_offset),
                int(center_x + pulse_size + line_length),
                int(center_y + y_offset)
            )
        
        # Draw audio wave animation when speaking
        if self.is_speaking:
            wave_color = QColor(self.primary_color)
            wave_color.setAlphaF(0.9)
            painter.setPen(QPen(wave_color, 3))
            
            # Draw audio waveform bars
            bar_width = 6
            bar_gap = 3
            num_bars = 5
            total_width = num_bars * bar_width + (num_bars - 1) * bar_gap
            start_x = center_x - total_width / 2
            
            for i in range(num_bars):
                # Calculate height based on animation
                bar_height = 10 + int(30 * ((math.sin(self.pulse_opacity * 6 + i * 0.8) + 1) / 2))
                
                bar_x = start_x + i * (bar_width + bar_gap)
                painter.drawRoundedRect(
                    int(bar_x),
                    int(center_y - bar_height / 2),
                    bar_width,
                    bar_height,
                    2, 2
                )
        
        # Draw active state indicator when listening
        if self.is_listening:
            # Set up colors for listening indicator
            indicator_color = QColor(self.accent_color)
            indicator_color.setAlphaF(0.8 * (0.5 + 0.5 * self.pulse_opacity))
            
            # Draw pulsing ring
            painter.setPen(Qt.NoPen)
            painter.setBrush(QBrush(indicator_color))
            ring_size = pulse_size * 1.3
            painter.drawEllipse(
                int(center_x - ring_size / 2),
                int(center_y - ring_size / 2),
                int(ring_size),
                int(ring_size)
            )
            
            # Draw microphone icon
            mic_color = QColor(255, 255, 255)
            painter.setPen(QPen(mic_color, 3))
            painter.setBrush(Qt.NoBrush)
            
            # Mic body
            mic_width = pulse_size * 0.25
            mic_height = pulse_size * 0.4
            painter.drawRoundedRect(
                int(center_x - mic_width / 2),
                int(center_y - mic_height / 2),
                int(mic_width),
                int(mic_height),
                int(mic_width / 2),
                int(mic_width / 2)
            )
            
            # Mic stand
            painter.drawLine(
                int(center_x),
                int(center_y + mic_height / 2),
                int(center_x),
                int(center_y + mic_height * 0.8)
            )
            
            # Mic base
            painter.drawLine(
                int(center_x - mic_width / 2),
                int(center_y + mic_height * 0.8),
                int(center_x + mic_width / 2),
                int(center_y + mic_height * 0.8)
            )
    
    def update_animation(self):
        """Update animation parameters for the next frame"""
        # Update pulse effect for speaking/listening
        self.pulse_opacity += self.pulse_direction
        if self.pulse_opacity > 1.0 or self.pulse_opacity < 0.0:
            self.pulse_direction *= -1
            self.pulse_opacity = max(0.0, min(1.0, self.pulse_opacity))
        
        # Refresh the view
        self.update()
    
    def update_breathing(self):
        """Update breathing animation"""
        if self.breath_in:
            self.breath_offset -= 0.1
            if self.breath_offset <= -2:
                self.breath_in = False
        else:
            self.breath_offset += 0.1
            if self.breath_offset >= 2:
                self.breath_in = True
    
    def blink_eyes(self):
        """Perform an eye blink"""
        self.eye_blink = True
        QTimer.singleShot(150, self._stop_blink)
        
        # Reset blink timer with random interval
        self.blink_timer.start(random.randint(3000, 6000))
    
    def _stop_blink(self):
        """Stop blinking"""
        self.eye_blink = False
    
    def _idle_animation_loop(self):
        """Background thread for idle animations"""
        while not self.idle_stop_event.is_set():
            # Only do idle animations when not speaking or listening
            if not self.is_speaking and not self.is_listening:
                # Random subtle head movements
                if random.random() < 0.02:  # 2% chance per cycle
                    self._perform_head_movement()
                
                # Random emotion changes when idle for a while
                if random.random() < 0.005:  # 0.5% chance per cycle
                    emotions = ["neutral", "happy", "thinking"]
                    self.set_emotion(random.choice(emotions))
            
            # Sleep to avoid consuming too much CPU
            time.sleep(0.1)
    
    def _perform_head_movement(self):
        """Perform a subtle head movement"""
        # Random movement
        target_x = random.randint(-5, 5)
        target_y = random.randint(-3, 3)
        
        # Create animation for smooth movement
        for i in range(10):
            progress = i / 10.0
            self.head_offset = QPoint(
                int(progress * target_x),
                int(progress * target_y)
            )
            time.sleep(0.02)
        
        # Hold briefly
        time.sleep(0.5)
        
        # Return to center
        for i in range(15):
            progress = i / 15.0
            self.head_offset = QPoint(
                int(target_x * (1.0 - progress)),
                int(target_y * (1.0 - progress))
            )
            time.sleep(0.02)
    
    def set_emotion(self, emotion: str):
        """Set character emotion"""
        valid_emotions = ["neutral", "happy", "sad", "surprised", "thinking"]
        if emotion in valid_emotions:
            self.current_emotion = emotion
            self.current_eyes = emotion
            self.current_mouth = emotion
            self.current_eyebrows = emotion
            
            # Set appropriate effects
            self.current_effects = []
            if emotion == "thinking":
                self.current_effects.append("glow_purple")
            elif emotion == "happy":
                self.current_effects.append("glow_teal")
            
            logger.info(f"Character emotion set to: {emotion}")
        else:
            logger.warning(f"Invalid emotion: {emotion}")
    
    def on_wake_word(self):
        """Handle wake word detection event"""
        # First show surprised emotion
        self.set_emotion("surprised")
        
        # Animate listening
        self.on_listening(True)
        
        # Schedule to stop listening after a delay
        QTimer.singleShot(3000, lambda: self.on_listening(False))
        
        # Log the event
        logger.info("Wake word detected, animating character response")
    
    def on_listening(self, is_listening):
        """Handle listening state changes"""
        self.is_listening = is_listening
        
        if is_listening:
            self.set_emotion("surprised")
            self.current_effects.append("listening")
            logger.info("Listening started, animating character")
        else:
            self.set_emotion("neutral")
            if "listening" in self.current_effects:
                self.current_effects.remove("listening")
            logger.info("Listening stopped, returning to neutral")
    
    def on_processing(self, is_processing):
        """Handle processing state changes"""
        if is_processing:
            self.set_emotion("thinking")
            self.current_effects.append("thinking")
            logger.info("Processing started, showing thinking animation")
        else:
            self.set_emotion("neutral")
            if "thinking" in self.current_effects:
                self.current_effects.remove("thinking")
            logger.info("Processing completed, returning to neutral")
    
    def on_speaking(self, text=None):
        """Handle speaking state changes"""
        self.is_speaking = True
        
        if text:
            # If we have text, estimate duration based on text length
            # Roughly 100 characters per second
            duration = max(1000, len(text) * 10)
            self.set_emotion("happy")
            self.current_effects.append("speaking")
            
            # Create a timer to stop the speaking animation
            QTimer.singleShot(duration, self._stop_speaking)
            
            logger.info(f"Speaking started, animating for {duration}ms")
        else:
            # If no text, use a default duration
            QTimer.singleShot(1000, self._stop_speaking)
            logger.info("Speaking started with default duration")
    
    def _stop_speaking(self):
        """Stop speaking animation"""
        self.is_speaking = False
        if "speaking" in self.current_effects:
            self.current_effects.remove("speaking")
        self.animation_complete.emit()
        logger.info("Speaking animation stopped")
    
    def on_idle(self, is_idle=True):
        """Handle idle state changes"""
        if is_idle:
            self.set_emotion("neutral")
            logger.info("Idle state activated, returning to neutral")
    
    def set_energy_level(self, level: float):
        """Set the character's energy level (0.0 to 1.0)"""
        self.energy_level = max(0.0, min(1.0, level))
        self.update()
    
    # Make sure to clean up the thread on close
    def closeEvent(self, event):
        """Clean up threads on close"""
        self.idle_stop_event.set()
        if self.idle_thread.is_alive():
            self.idle_thread.join(timeout=1.0)
        super().closeEvent(event)
    
    def _paint_face(self, painter, center_x, center_y, radius):
        """Paint the character's face - realistic anime-style female character"""
        # Draw head shape - more realistic anime face
        skin_color = QColor(245, 230, 225)  # Pale skin tone
        painter.setPen(QPen(QColor(40, 30, 35), 1))  # Darker subtle outline
        painter.setBrush(QBrush(skin_color))
        
        # Apply head tilt if any
        painter.save()
        painter.translate(center_x, center_y)
        painter.rotate(self.head_tilt)
        painter.translate(-center_x, -center_y)
        
        # Draw face shape - more realistic oval face
        face_path = QPainterPath()
        
        # Top of head
        face_path.moveTo(center_x - radius * 0.65, center_y - radius * 0.7)
        face_path.quadTo(center_x, center_y - radius * 0.85, center_x + radius * 0.65, center_y - radius * 0.7)
        
        # Right side of face
        face_path.quadTo(center_x + radius * 0.75, center_y, center_x + radius * 0.55, center_y + radius * 0.6)
        
        # Chin (more natural)
        face_path.quadTo(center_x, center_y + radius * 0.75, center_x - radius * 0.55, center_y + radius * 0.6)
        
        # Left side of face
        face_path.quadTo(center_x - radius * 0.75, center_y, center_x - radius * 0.65, center_y - radius * 0.7)
        
        painter.drawPath(face_path)
        
        # Draw dark hair like in the reference image
        self._paint_dark_hair(painter, center_x, center_y, radius)
        
        # Draw realistic eyes
        self._paint_realistic_eyes(painter, center_x, center_y, radius)
        
        # Draw eyebrows
        self._paint_dark_eyebrows(painter, center_x, center_y, radius)
        
        # Draw nose
        self._paint_realistic_nose(painter, center_x, center_y, radius)
        
        # Draw mouth
        self._paint_realistic_mouth(painter, center_x, center_y, radius)
        
        # Draw additional facial details
        self._paint_realistic_details(painter, center_x, center_y, radius)
        
        # Add cyberpunk lighting effects
        self._paint_cyberpunk_lighting(painter, center_x, center_y, radius)
        
        # Restore painter
        painter.restore()
    
    def _paint_dark_hair(self, painter, center_x, center_y, radius):
        """Paint realistic dark hair like in the reference image"""
        # Hair colors - dark with teal/cyan highlights for cyberpunk effect
        hair_color = QColor(15, 20, 25)  # Very dark hair
        hair_highlight_teal = QColor(0, 220, 200, 120)  # Teal highlight
        hair_highlight_purple = QColor(130, 0, 200, 120)  # Purple highlight
        
        # Create gradient for the cyberpunk effect
        gradient = QRadialGradient(center_x + radius * 0.3, center_y - radius * 0.2, radius * 2.2)
        gradient.setColorAt(0.4, hair_color)
        gradient.setColorAt(0.7, QColor(30, 35, 40))
        gradient.setColorAt(1.0, QColor(10, 15, 20))
        
        # Hair silhouette
        hair_path = QPainterPath()
        
        # Top of hair with volume - slightly messy
        hair_path.moveTo(center_x - radius * 0.8, center_y - radius * 0.5)
        hair_path.quadTo(center_x - radius * 0.4, center_y - radius * 1.1, center_x, center_y - radius * 0.9)
        hair_path.quadTo(center_x + radius * 0.4, center_y - radius * 1.1, center_x + radius * 0.8, center_y - radius * 0.5)
        
        # Right side - longer hair like the reference image
        hair_path.lineTo(center_x + radius * 0.95, center_y + radius * 0.3)
        
        # Medium-length hair with slight wave
        hair_path.quadTo(center_x + radius * 1.0, center_y + radius * 0.8, center_x + radius * 0.7, center_y + radius * 1.3)
        
        # Bottom/back of hair
        hair_path.quadTo(center_x + radius * 0.3, center_y + radius * 1.6, center_x, center_y + radius * 1.5)
        hair_path.quadTo(center_x - radius * 0.3, center_y + radius * 1.6, center_x - radius * 0.7, center_y + radius * 1.3)
        
        # Left side - longer hair with wave
        hair_path.quadTo(center_x - radius * 1.0, center_y + radius * 0.8, center_x - radius * 0.95, center_y + radius * 0.3)
        
        # Close the path
        hair_path.closeSubpath()
        
        # Set gradient brush for the hair
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(gradient))
        painter.drawPath(hair_path)
        
        # Add some loose strands of hair
        painter.setPen(QPen(hair_color, 1.5))
        
        # Left side loose strand
        strand_path1 = QPainterPath()
        strand_path1.moveTo(center_x - radius * 0.7, center_y - radius * 0.3)
        strand_path1.quadTo(center_x - radius * 0.9, center_y, center_x - radius * 0.8, center_y + radius * 0.4)
        strand_path1.quadTo(center_x - radius * 0.7, center_y + radius * 0.7, center_x - radius * 0.6, center_y + radius * 0.9)
        painter.drawPath(strand_path1)
        
        # Right side loose strand
        strand_path2 = QPainterPath()
        strand_path2.moveTo(center_x + radius * 0.5, center_y - radius * 0.2)
        strand_path2.quadTo(center_x + radius * 0.65, center_y + radius * 0.2, center_x + radius * 0.7, center_y + radius * 0.6)
        strand_path2.quadTo(center_x + radius * 0.8, center_y + radius * 0.9, center_x + radius * 0.6, center_y + radius * 1.2)
        painter.drawPath(strand_path2)
        
        # Face-framing strand
        strand_path3 = QPainterPath()
        strand_path3.moveTo(center_x - radius * 0.2, center_y - radius * 0.5)
        strand_path3.quadTo(center_x - radius * 0.3, center_y - radius * 0.3, center_x - radius * 0.35, center_y - radius * 0.1)
        strand_path3.quadTo(center_x - radius * 0.4, center_y + radius * 0.2, center_x - radius * 0.45, center_y + radius * 0.5)
        painter.drawPath(strand_path3)
        
        # Add cyberpunk-style colored highlights
        # Teal highlight on left
        highlight_path1 = QPainterPath()
        highlight_path1.moveTo(center_x - radius * 0.7, center_y - radius * 0.4)
        highlight_path1.quadTo(center_x - radius * 0.8, center_y, center_x - radius * 0.7, center_y + radius * 0.5)
        
        painter.setPen(QPen(hair_highlight_teal, 5))
        painter.drawPath(highlight_path1)
        
        # Purple highlight on right
        highlight_path2 = QPainterPath()
        highlight_path2.moveTo(center_x + radius * 0.6, center_y - radius * 0.3)
        highlight_path2.quadTo(center_x + radius * 0.7, center_y + radius * 0.2, center_x + radius * 0.65, center_y + radius * 0.7)
        
        painter.setPen(QPen(hair_highlight_purple, 5))
        painter.drawPath(highlight_path2)
        
        # Add bangs over forehead like in the reference image
        bangs_path = QPainterPath()
        
        # Left part of bangs
        bangs_path.moveTo(center_x - radius * 0.5, center_y - radius * 0.6)
        bangs_path.quadTo(center_x - radius * 0.3, center_y - radius * 0.3, center_x - radius * 0.2, center_y - radius * 0.4)
        
        # Center part of bangs
        bangs_path.quadTo(center_x, center_y - radius * 0.3, center_x + radius * 0.2, center_y - radius * 0.4)
        
        # Right part of bangs
        bangs_path.quadTo(center_x + radius * 0.3, center_y - radius * 0.3, center_x + radius * 0.5, center_y - radius * 0.6)
        
        painter.setPen(QPen(hair_color, 2))
        painter.drawPath(bangs_path)

    def _paint_cyberpunk_lighting(self, painter, center_x, center_y, radius):
        """Add cyberpunk-style lighting effects to the character"""
        # Create teal lighting on left side (like the reference image)
        gradient_teal = QRadialGradient(center_x - radius * 0.8, center_y, radius * 1.5)
        gradient_teal.setColorAt(0, QColor(0, 220, 200, 60))  # Teal
        gradient_teal.setColorAt(0.5, QColor(0, 220, 200, 20))
        gradient_teal.setColorAt(1, QColor(0, 0, 0, 0))
        
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(gradient_teal))
        painter.setOpacity(0.7)
        painter.drawEllipse(
            int(center_x - radius * 1.5),
            int(center_y - radius),
            int(radius * 2),
            int(radius * 2)
        )
        
        # Create pink/red lighting on right side (like the reference image)
        gradient_pink = QRadialGradient(center_x + radius * 0.8, center_y, radius * 1.5)
        gradient_pink.setColorAt(0, QColor(220, 50, 100, 60))  # Pink
        gradient_pink.setColorAt(0.5, QColor(220, 50, 100, 20))
        gradient_pink.setColorAt(1, QColor(0, 0, 0, 0))
        
        painter.setBrush(QBrush(gradient_pink))
        painter.drawEllipse(
            int(center_x),
            int(center_y - radius),
            int(radius * 2),
            int(radius * 2)
        )
        
        # Add some small glowing dots for cyberpunk effect
        small_glow_positions = [
            (center_x - radius * 0.9, center_y - radius * 0.5, self.primary_color),
            (center_x + radius * 0.9, center_y - radius * 0.5, self.accent_color),
            (center_x - radius * 0.8, center_y + radius * 0.7, self.primary_color),
            (center_x + radius * 0.8, center_y + radius * 0.7, self.accent_color)
        ]
        
        for x, y, color in small_glow_positions:
            glow = QRadialGradient(x, y, radius * 0.1)
            glow_color = QColor(color)
            glow_color.setAlpha(150)
            glow.setColorAt(0, glow_color)
            glow.setColorAt(1, QColor(glow_color.red(), glow_color.green(), glow_color.blue(), 0))
            
            painter.setBrush(QBrush(glow))
            painter.drawEllipse(
                int(x - radius * 0.1),
                int(y - radius * 0.1),
                int(radius * 0.2),
                int(radius * 0.2)
            )
        
        painter.setOpacity(1.0)

    def _paint_ambient_features(self, painter, center_x, center_y, radius):
        """Paint ambient cyberpunk features around the anime character"""
        # Add subtle tech-inspired elements
        painter.setPen(QPen(self.primary_color, 1))
        
        # Left side tech lines
        painter.drawLine(
            int(center_x - radius * 1.1),
            int(center_y - radius * 0.3),
            int(center_x - radius * 0.9),
            int(center_y - radius * 0.3)
        )
        
        painter.drawLine(
            int(center_x - radius * 1.1),
            int(center_y),
            int(center_x - radius * 0.95),
            int(center_y)
        )
        
        painter.drawLine(
            int(center_x - radius * 1.1),
            int(center_y + radius * 0.3),
            int(center_x - radius * 0.9),
            int(center_y + radius * 0.3)
        )
        
        # Right side tech lines
        painter.drawLine(
            int(center_x + radius * 0.9),
            int(center_y - radius * 0.3),
            int(center_x + radius * 1.1),
            int(center_y - radius * 0.3)
        )
        
        painter.drawLine(
            int(center_x + radius * 0.95),
            int(center_y),
            int(center_x + radius * 1.1),
            int(center_y)
        )
        
        painter.drawLine(
            int(center_x + radius * 0.9),
            int(center_y + radius * 0.3),
            int(center_x + radius * 1.1),
            int(center_y + radius * 0.3)
        )
        
        # Add small tech "nodes"
        painter.setBrush(QBrush(self.primary_color))
        
        # Left nodes
        for y_offset in [-0.3, 0, 0.3]:
            painter.drawEllipse(
                int(center_x - radius * 1.1) - 2,
                int(center_y + radius * y_offset) - 2,
                4, 4
            )
        
        # Right nodes
        for y_offset in [-0.3, 0, 0.3]:
            painter.drawEllipse(
                int(center_x + radius * 1.1) - 2,
                int(center_y + radius * y_offset) - 2,
                4, 4
            )
        
        # Add some anime-style tech elements - glowing circles/patterns
        glow_color = QColor(self.accent_color)
        glow_color.setAlpha(50)
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(glow_color))
        
        # Top tech circle
        painter.drawEllipse(
            int(center_x - radius * 0.15),
            int(center_y - radius * 1.2),
            int(radius * 0.3),
            int(radius * 0.3)
        )
        
        # Bottom tech patterns
        pattern_path = QPainterPath()
        pattern_path.moveTo(center_x - radius * 0.2, center_y + radius * 1.1)
        pattern_path.lineTo(center_x, center_y + radius * 1.2)
        pattern_path.lineTo(center_x + radius * 0.2, center_y + radius * 1.1)
        pattern_path.closeSubpath()
        
        painter.drawPath(pattern_path)
        
        # Add cyberpunk lighting effects like in the reference image
        self._paint_cyberpunk_lighting(painter, center_x, center_y, radius)

    def _check_assets_loaded(self):
        """Check if the required assets are loaded"""
        # Check base parts
        if not self.character_parts['base'] or not self.character_parts['hair']:
            return False
            
        # Check if we have at least one of each type of eye, mouth, and eyebrow
        if not self.character_parts['eyes'] or not self.character_parts['mouth'] or not self.character_parts['eyebrows']:
            return False
            
        # Check if we have the current state
        if self.current_eyes not in self.character_parts['eyes']:
            return False
            
        if self.current_mouth not in self.character_parts['mouth']:
            return False
            
        if self.current_eyebrows not in self.character_parts['eyebrows']:
            return False
            
        return True

    def _paint_realistic_eyes(self, painter, center_x, center_y, radius):
        """Paint realistic anime-style eyes"""
        # Eye colors - using cyberpunk theme
        iris_color = QColor(20, 180, 220)  # Bright cyan/blue
        eye_white = QColor(240, 240, 245)
        
        # Eye positions (adjusted for face shape)
        left_eye_x = center_x - radius * 0.25
        right_eye_x = center_x + radius * 0.25
        eyes_y = center_y - radius * 0.05
        
        # Eye size
        eye_width = radius * 0.2
        eye_height = radius * 0.1
        
        # Eye whites
        painter.setPen(QPen(QColor(60, 60, 60), 1))
        painter.setBrush(QBrush(eye_white))
        
        # Left eye white
        left_eye_rect = QRect(
            int(left_eye_x - eye_width/2),
            int(eyes_y - eye_height/2),
            int(eye_width),
            int(eye_height)
        )
        painter.drawEllipse(left_eye_rect)
        
        # Right eye white
        right_eye_rect = QRect(
            int(right_eye_x - eye_width/2),
            int(eyes_y - eye_height/2),
            int(eye_width),
            int(eye_height)
        )
        painter.drawEllipse(right_eye_rect)
        
        # Draw irises
        iris_size = eye_height * 0.8
        painter.setBrush(QBrush(iris_color))
        
        # Add blinking
        if not self.eye_blink:
            # Left iris
            painter.drawEllipse(
                int(left_eye_x - iris_size/2),
                int(eyes_y - iris_size/2),
                int(iris_size),
                int(iris_size)
            )
            
            # Right iris
            painter.drawEllipse(
                int(right_eye_x - iris_size/2),
                int(eyes_y - iris_size/2),
                int(iris_size),
                int(iris_size)
            )
            
            # Pupils
            painter.setPen(Qt.NoPen)
            painter.setBrush(QBrush(QColor(0, 0, 0)))
            pupil_size = iris_size * 0.5
            
            # Left pupil
            painter.drawEllipse(
                int(left_eye_x - pupil_size/2),
                int(eyes_y - pupil_size/2),
                int(pupil_size),
                int(pupil_size)
            )
            
            # Right pupil
            painter.drawEllipse(
                int(right_eye_x - pupil_size/2),
                int(eyes_y - pupil_size/2),
                int(pupil_size),
                int(pupil_size)
            )
            
            # Highlights
            painter.setBrush(QBrush(QColor(255, 255, 255, 180)))
            highlight_size = pupil_size * 0.5
            
            # Left eye highlight
            painter.drawEllipse(
                int(left_eye_x - pupil_size*0.2 - highlight_size/2),
                int(eyes_y - pupil_size*0.2 - highlight_size/2),
                int(highlight_size),
                int(highlight_size)
            )
            
            # Right eye highlight
            painter.drawEllipse(
                int(right_eye_x - pupil_size*0.2 - highlight_size/2),
                int(eyes_y - pupil_size*0.2 - highlight_size/2),
                int(highlight_size),
                int(highlight_size)
            )
        else:
            # Closed eyes - just draw lines
            painter.setPen(QPen(QColor(60, 60, 60), 2))
            painter.drawLine(
                int(left_eye_x - eye_width/2 + eye_width*0.1),
                int(eyes_y),
                int(left_eye_x + eye_width/2 - eye_width*0.1),
                int(eyes_y)
            )
            
            painter.drawLine(
                int(right_eye_x - eye_width/2 + eye_width*0.1),
                int(eyes_y),
                int(right_eye_x + eye_width/2 - eye_width*0.1),
                int(eyes_y)
            )

    def _paint_dark_eyebrows(self, painter, center_x, center_y, radius):
        """Paint dark eyebrows to match hair style"""
        # Eyebrow parameters
        eyebrow_color = QColor(20, 25, 30)  # Very dark to match hair
        
        # Positions (adjusted for face shape)
        left_brow_x = center_x - radius * 0.25
        right_brow_x = center_x + radius * 0.25
        brows_y = center_y - radius * 0.2
        
        # Size
        brow_width = radius * 0.22
        brow_height = radius * 0.04
        
        # Angle - adjusted for emotion
        left_angle = -10
        right_angle = 10
        
        if self.current_emotion == "surprised":
            brows_y -= radius * 0.05
            left_angle = -15
            right_angle = 15
        elif self.current_emotion == "sad":
            left_angle = 15
            right_angle = -15
        elif self.current_emotion == "thinking":
            right_angle = 20  # Raise one eyebrow
        
        # Draw eyebrows
        painter.setPen(QPen(eyebrow_color, brow_height, Qt.SolidLine, Qt.RoundCap))
        
        # Left eyebrow
        painter.save()
        painter.translate(left_brow_x, brows_y)
        painter.rotate(left_angle)
        painter.drawLine(-brow_width/2, 0, brow_width/2, 0)
        painter.restore()
        
        # Right eyebrow
        painter.save()
        painter.translate(right_brow_x, brows_y)
        painter.rotate(right_angle)
        painter.drawLine(-brow_width/2, 0, brow_width/2, 0)
        painter.restore()

    def _paint_realistic_nose(self, painter, center_x, center_y, radius):
        """Paint a subtle anime-style nose"""
        # Anime-style noses are often just a suggestion rather than fully drawn
        nose_color = QColor(40, 30, 35)
        nose_y = center_y + radius * 0.1
        
        # Simple line for nose
        painter.setPen(QPen(nose_color, 1))
        painter.drawLine(
            int(center_x),
            int(nose_y - radius * 0.05),
            int(center_x),
            int(nose_y)
        )
        
        # Small curve for nostrils - very subtle
        path = QPainterPath()
        path.moveTo(center_x - radius * 0.05, nose_y + radius * 0.02)
        path.cubicTo(
            center_x, nose_y + radius * 0.03,
            center_x, nose_y + radius * 0.03,
            center_x + radius * 0.05, nose_y + radius * 0.02
        )
        
        painter.setPen(QPen(nose_color, 1))
        painter.drawPath(path)

    def _paint_realistic_mouth(self, painter, center_x, center_y, radius):
        """Paint anime-style mouth with expressions"""
        # Mouth parameters based on emotion
        mouth_y = center_y + radius * 0.3
        mouth_width = radius * 0.3
        
        # Lip color - soft pink
        lip_color = QColor(220, 140, 170)
        
        if self.current_emotion == "happy" or self.is_speaking:
            # Smiling mouth or speaking
            painter.setPen(QPen(QColor(40, 30, 35), 1))
            painter.setBrush(QBrush(QColor(40, 30, 35, 100)))
            
            # Draw a curved smile
            smile_path = QPainterPath()
            smile_path.moveTo(center_x - mouth_width/2, mouth_y)
            smile_path.quadTo(
                center_x, mouth_y + radius * 0.1,
                center_x + mouth_width/2, mouth_y
            )
            
            # When speaking, make the mouth more open
            if self.is_speaking:
                # Calculate mouth openness based on animation frame
                openness = radius * 0.08 * (0.5 + 0.5 * self.pulse_opacity)
                
                # Draw the top curve
                smile_path.lineTo(center_x + mouth_width/2, mouth_y)
                
                # Draw the bottom curve
                smile_path.quadTo(
                    center_x, mouth_y + openness,
                    center_x - mouth_width/2, mouth_y
                )
                
                smile_path.closeSubpath()
                painter.drawPath(smile_path)
        else:
                # Just draw the smile line for happy
                painter.drawPath(smile_path)
                
                # Add a small highlight/glimmer on the lip
                painter.setPen(QPen(lip_color, 1))
                highlight_path = QPainterPath()
                highlight_path.moveTo(center_x - mouth_width/4, mouth_y - radius * 0.01)
                highlight_path.quadTo(
                    center_x, mouth_y - radius * 0.02,
                    center_x + mouth_width/4, mouth_y - radius * 0.01
                )
                painter.drawPath(highlight_path)
                
        elif self.current_emotion == "sad":
            # Sad mouth - inverted curve
            painter.setPen(QPen(QColor(40, 30, 35), 1))
            sad_path = QPainterPath()
            sad_path.moveTo(center_x - mouth_width/2, mouth_y)
            sad_path.quadTo(
                center_x, mouth_y - radius * 0.05,
                center_x + mouth_width/2, mouth_y
            )
            painter.drawPath(sad_path)
            
        elif self.current_emotion == "surprised":
            # Surprised "o" mouth
            painter.setPen(QPen(QColor(40, 30, 35), 1))
            painter.setBrush(QBrush(QColor(40, 30, 35, 100)))
            
            # Small oval for surprise
            surprise_size = radius * 0.15
            painter.drawEllipse(
                int(center_x - surprise_size/2),
                int(mouth_y - surprise_size/2),
                int(surprise_size),
                int(surprise_size)
            )
            
        elif self.current_emotion == "thinking":
            # Thinking mouth - small line, slightly to one side
            painter.setPen(QPen(QColor(40, 30, 35), 1.5))
            painter.drawLine(
                int(center_x - mouth_width/4),
                int(mouth_y),
                int(center_x + mouth_width/4),
                int(mouth_y)
            )
            
        else:
            # Neutral mouth - simple line with slight curve
            painter.setPen(QPen(lip_color, 1.5))
            painter.drawLine(
                int(center_x - mouth_width/3),
                int(mouth_y),
                int(center_x + mouth_width/3),
                int(mouth_y)
            )
            
            # Add a small highlight/glimmer on the lip
            painter.setPen(QPen(lip_color, 1))
            highlight_path = QPainterPath()
            highlight_path.moveTo(center_x - mouth_width/5, mouth_y - radius * 0.01)
            highlight_path.quadTo(
                center_x, mouth_y - radius * 0.02,
                center_x + mouth_width/5, mouth_y - radius * 0.01
            )
            painter.drawPath(highlight_path)

    def _paint_realistic_details(self, painter, center_x, center_y, radius):
        """Paint additional facial details for realism"""
        # Add blush to cheeks for some emotions
        if self.current_emotion in ["happy", "surprised"]:
            blush_color = QColor(255, 150, 150, 60)
            painter.setPen(Qt.NoPen)
            painter.setBrush(QBrush(blush_color))
            
            # Left cheek
            painter.drawEllipse(
                int(center_x - radius * 0.4),
                int(center_y + radius * 0.1),
                int(radius * 0.2),
                int(radius * 0.1)
            )
            
            # Right cheek
            painter.drawEllipse(
                int(center_x + radius * 0.2),
                int(center_y + radius * 0.1),
                int(radius * 0.2),
                int(radius * 0.1)
            )
        
        # Add subtle shadows for dimension
        shadow_color = QColor(40, 30, 35, 20)
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(shadow_color))
        
        # Jawline shadow
        jaw_shadow = QPainterPath()
        jaw_shadow.moveTo(center_x - radius * 0.4, center_y + radius * 0.4)
        jaw_shadow.quadTo(
            center_x, center_y + radius * 0.5,
            center_x + radius * 0.4, center_y + radius * 0.4
        )
        jaw_shadow.quadTo(
            center_x + radius * 0.35, center_y + radius * 0.45,
            center_x, center_y + radius * 0.6
        )
        jaw_shadow.quadTo(
            center_x - radius * 0.35, center_y + radius * 0.45,
            center_x - radius * 0.4, center_y + radius * 0.4
        )
        
        painter.drawPath(jaw_shadow)
        
        # Add cyberpunk-style facial markings or tattoos
        if self.energy_level > 0.7:
            # Only show markings when energy is high
            mark_color = QColor(0, 220, 200, 150)  # Cyan
            painter.setPen(QPen(mark_color, 1))
            
            # Left side marking
            painter.drawLine(
                int(center_x - radius * 0.6),
                int(center_y - radius * 0.1),
                int(center_x - radius * 0.4),
                int(center_y - radius * 0.1)
            )
            painter.drawLine(
                int(center_x - radius * 0.4),
                int(center_y - radius * 0.1),
                int(center_x - radius * 0.4),
                int(center_y + radius * 0.1)
            )
            
            # Right side marking
            mark_color = QColor(220, 50, 100, 150)  # Pink
            painter.setPen(QPen(mark_color, 1))
            painter.drawLine(
                int(center_x + radius * 0.6),
                int(center_y - radius * 0.1),
                int(center_x + radius * 0.4),
                int(center_y - radius * 0.1)
            )
            painter.drawLine(
                int(center_x + radius * 0.4),
                int(center_y - radius * 0.1),
                int(center_x + radius * 0.4),
                int(center_y + radius * 0.1)
            )

# For testing directly
if __name__ == "__main__":
    import sys
    from PyQt5.QtWidgets import QApplication
    
    app = QApplication(sys.argv)
    
    widget = CharacterView()
    widget.resize(500, 500)
    widget.show()
    
    # Test animations
    widget.on_speaking("Hello, I am Ana, your AI assistant. How can I help you today?")
    
    sys.exit(app.exec_()) 